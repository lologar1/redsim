enum Rotation
	8 rotations are defined (fits in 3 bits). In order: NONE, NORTH, WEST, SOUTH, EAST, UP, DOWN and COMPLEX

	NONE and NORTH visually act as the same; by convention, all blocks which do not support rotation should
	use NONE.

	For every other rotations, the mesh as defined on disk (.mesh and .boundingbox files) is facing NORTH, which,
	by convention of the left-handed coordinate system, points towards +X, +Y, +Z (WEST, UP, NORTH)

	COMPLEX rotations (TODO) are not currently supported, and act as a placeholder for the time being.

struct Blockmesh
	A Blockmesh, also referred to as a template or mesh template, stores data describing a single blockmesh
	before it is sent to the larger chunk VAO which is then sent to the GPU for rendering.

	Because opaque and trans vertices (and thus indices) are kept separate for OIT, each has its "buffer"
	(float * for vertices, unsigned int * for indices), of which the sizes are kept in count (unsigned int [4])

	IMPORTANT: sizes kept in count refer to the number of members, NOT the number of bytes!
	This is because the member counts are required for such things as index offsetting, and it wouldn't do to
	divide by sizeof(type) each time they are required.

struct Blockdata
	A Blockdata is a 64-bit struct containing all the data necessary to describe a single block server-side,
	meaning there is no mesh or rendering information.

	unsigned int id (13 bits)
		Type of block (example: silicon; encompasses the "silicon" category)

	unsigned int variant (8 bits)
		Block variant (example: silicon_green is a variant of the broader "silicon" category)

	Rotation rotation (3 bits)
		Block rotation (see above)

	unsigned int metadata (32 bits)
		Special information such as property flags (see RSM_BIT_...)

Chunkdata[CHUNKSIZE][CHUNKSIZE][CHUNKSIZE]
	3D array of Blockdata of side CHUNKSIZE

Scratchpad buffers
	extern float *opaqueVertexBuffer, *transVertexBuffer
	extern unsigned int *opaqueIndexBuffer, *transIndexBuffer
		Allocated in parseBlockdata (see renderutils) such that they are big enough to hold a chunk full of
		the largest meshes (this way, there is no need to keep a dynamic buffer to accumulate meshes when
		remeshing a chunk)

	extern Blockmesh ***blockmeshes
		Populated in parseBlockdata (see renderutils) too (as it has access to files) and holds the template
		(non-rotated, non-translocated, non-offset-adjusted) Blockmeshes for reference when remeshing.

		Indirection layers (3):
			Block id -> Block variant -> Blockmesh *
			The reason the template is referred to by a pointer and not directly accessed is because getBlockmesh
			needs to memcpy the template data into a scratchpad buffer, which is done by reference.

void remeshChunk(int64_t x, int64_t y, int64_t z)
	Takes in a Chunkdata (provided by conversion of xyz coords to a chunk index used as key in chunkmap) and
	updates (or creates, if it doesn't already exist) its sister buffer in meshmap which holds the rendering
	data for that chunk.

	Process
		First, find the Chunkdata * from chunkmap and GLuint * (GL buffer) from meshmap. Create the GPU-side
		chunk buffer if it doesn't exist.

		Then, iterate over all blocks in the chunk (CHUNKSIZE^3) and, for each one remesh it except if its id
		is 0 (air, or a variant thereof; air variants are actually used as special values to encode for
		non-placeable items, such as tools)

		Get the blockmesh (which is translocated and rotated by getBlockmesh) and store it in the temporary
		scratchpad blockmesh buffer. Note that, on parsing blockdata, all meshes are checked against their
		RSM_MAX_... values so there is no possibility of buffer overflow.

		Adjust indices against the running total as indices must be converted from relative (inside blockmesh)
		to absolute (inside chunkmesh) to proceed.

		Finally, append the buffers to the chunk scratchpad buffers (see above), which will be transferred over
		to the GPU once all blocks have been processed.

	Note that the CPU-side Chunkdata needs to exist for remeshing to proceed.
	Also note that the GPU-side buffers are not freed when a chunk becomes empty, as it may be used again.

void generateMeshlist(void) & updateMeshlist(void)
	For generateMeshlist, reallocate the meshes array (holds chunks to be drawn every frame) to concord with
	current render distance, then calls updateMeshlist to populate it.

	updateMeshlist iterates over all chunks in the visible render distance cube and adds it to the meshes
	array if it exists (is preesent in meshmap). Increments nmesh to account for it.

void translocationMatrix(mat4 translocation, vec3 translation, Rotation rotation)
void rotationMatrix(mat4 rotAdjust, Rotation rotation, vec3 meshcenter)
	Creates a mat4 in the first argument which either translocates (translates and rotates) or only rotates.

	The rotation is centered around meshcenter; this value is the actual MESHCENTER constant when rotationMatrix
	is called from translocationMatrix as it translocates from the origin.

void pathcat(char *destination, int n, ...)
	Concatenates paths. Utility function.
