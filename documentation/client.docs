Camera data
	float pitch, yaw
		Values in degrees, pitch is kept between -89 to 89 to avoid breaking necks (and projection inversions)

	vec3 orientation, position
		Orientation is a normalized vector pointing in the direction the camera is facing. Calculated each frame.
		Position is handled by rsm_move (see redsim) and is the 3D position of the camera in space.

usf_hashmap *chunkmap
	Associates a chunk index to its Chunkdata. A chunk index is a uint64_t representing three signed coordinates
	(x, y, z) put together. Each coordinate is 21 bits (21 * 3 = 63) so the maximum world size is
	(2^21-1) * CHUNKSIZE blocks cubed.

	Interesting thing to note (TODO confirm this): since chunk displaying and interaction is done through 21-bit
	indices which may overflow at the "edges" of the world, such an "edge" should actually wrap around to
	negative values seamlessly, except camera position is a float (which doesn't overflow at 21 bits) and thus
	won't render the chunk properly.

usf_hashmap *meshmap
	Maps a chunk index to an array of 4 GLuint (opaque GPU buffer, trans GPU buffer, and index count for both)

GLuint **meshes
int nmesh
	Meshes holds current meshes (arrays of 4 GLuint as stated above) for rendering while mesh indicates the
	number of such arrays (chunks) are to be rendered.

void client_init(void)
	Initialize important global variables such as chunkmap, hashmap, namemap, etc.
	Call parsing functions (parseBlockdata, parseGUIdata) to read disk and populate structures.
	Call initGUI() (see gui)
	Call generateMeshlist() once to begin with chunks shown on screen
	Call renderGUI() once to begin with GUI shown on screen

void client_frameEvent(GLFWwindow *window)
	Called each frame by the renderer and adjust per-frame variables like camera orientation and position
	(the latter through rsm_move).

	Also checks for chunk border crossing and update meshlist, or render distance (call generateMeshlist).

void client_getOrientationVector(vec3 ori)
void client_getPosition(vec3 pos)
	Query and copy client variables.
